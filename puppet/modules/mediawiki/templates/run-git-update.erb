#!/usr/bin/env bash
# Update local git repositories
# Command run in VM by `vagrant git-update`

. /etc/profile.d/set_MW_INSTALL_PATH.sh

set -u
declare -a UPDATE_ERRORS

UPDATE_ERRORS=( )

function pull {
  print_empty_line=''
  if [[ $# -eq 0 ]]; then
    echo -e "\e[36m==> Updating $(pwd) ...\e[0m"
    print_empty_line='yes'
  else
    echo "[*] Updating repo in $(pwd) ..."
  fi
  # some srv dirs may be still under root, chown them
  find . -uid 0 -exec sudo chown -R <%= "#{scope['::share_owner']}:#{scope['::share_group']}" %> {} \;
  branch=$(expr $(git symbolic-ref HEAD) : 'refs/heads/\(.*\)')
  if [[ -z "$branch" ]]; then
    git checkout master
    branch=$(expr $(git symbolic-ref HEAD) : 'refs/heads/\(.*\)')
  fi
  err=''
  if [[ -n "$branch" ]]; then
    remote=$(git config branch.${branch}.remote)
    if [[ -n "$remote" ]]; then
      url=$(git config --get remote.${remote}.url)
      if [[ $url == ssh://* ]]; then
        # Convert remote git url from ssh:// to anonymous https://
        tempurl=$(echo $url | sed -e 's!ssh://[^@]\+@!https://!g' -e 's!:29418!/r!g')
        git pull --rebase $tempurl
      else
        git pull --rebase
      fi
      if [[ $? -ne 0 ]]; then
        # If we didn't successfully update (possibly because we're on
        # a local branch), leave the submodules alone.
        err="GIT PULL failed in $(pwd) for branch '$branch'"
      else
        git submodule update --init --recursive
        if [[ $? -ne 0 ]]; then
          err="GIT SUBMODULE UPDATE failed in $(pwd) for branch '$branch'"
        fi
      fi
    else
      err="Remote not found in $(pwd) for branch '$branch'"
    fi
  else
    err="Unable to get current branch in $(pwd)"
  fi

  if [[ -n "$err" ]]; then
    echo -e "\e[1;31m ***** $err\e[0m"
    UPDATE_ERRORS+=("$err")
  fi

  [[ -n "${print_empty_line}" ]] && echo

}

# expose the needed npm env vars
export NPM_CONFIG_CACHE="<%= scope['::npm::cache_dir'] %>"
export NPM_CONFIG_GLOBAL=false
export LINK=g++
export HOME=/home/vagrant

# clear the npm module cache as earlier cached versions
# of larger modules cause npm to run out of memory
sudo rm -rf <%= scope['::npm::cache_dir'] %>/* /home/vagrant/.npm

for srvconf in <%= scope['::service::conf_dir'] %>/*.conf; do
  err=''
  source ${srvconf}
  echo -e "\e[36m==> Updating ${SERVICE_NAME} ...\e[0m"
  if [[ -n "${NEED_CHDIR}" && -d ${SERVICE_DIR} ]]; then
    cd "${SERVICE_DIR}"
    [[ -n "${DO_PULL}" ]] && pull no_title
    if [[ -n ${UPDATE_CMD} ]]; then
      echo "[*] Updating dependencies for ${SERVICE_NAME} ..."
      if ! /bin/sh -c "${UPDATE_CMD}"; then
        err="Could not update dependencies of ${SERVICE_NAME} !"
        echo -e "\e[1;31m ***** $err\e[0m"
        UPDATE_ERRORS+=("${err}")
      fi
    fi
  fi
  if [[ -n "${DO_RESTART}" && -z "${err}" ]]; then
    echo "[*] Restarting service ${RESTART_NAME} ..."
    sudo service ${RESTART_NAME} restart
  fi
  echo
done

cd "$MW_INSTALL_PATH"
pull

for f in extensions/*; do
  if [[ -d $f ]] && [[ -d $f/.git ]]; then
    pushd $f > /dev/null
    pull
    popd > /dev/null
  fi
done

for f in skins/*; do
  if [[ -d $f ]] && [[ -d $f/.git ]]; then
    pushd $f > /dev/null
    pull
    popd > /dev/null
  fi
done

for f in . extensions/*; do
  if [[ -d $f ]] && [[ -f $f/composer.json ]]; then
    pushd $f > /dev/null
    if git ls-files --error-unmatch composer.lock >/dev/null 2>&1; then
      # composer.lock is git-versioned, so rely on it
      composer_cmd=install
      composer_action=Installing
    else
      composer_cmd=update
      composer_action=Updating
    fi

    echo -e "\e[36m==> ${composer_action} composer dependencies in $(pwd) ...\e[0m"
    composer "$composer_cmd" --no-interaction --optimize-autoloader
    popd > /dev/null
    echo
  fi
done

echo -e "\e[36m==> Updating database ...\e[0m"
foreachwiki update.php --quick --doshared

if [[ ${#UPDATE_ERRORS[@]} -ne 0 ]]; then
  echo
  echo -e "\e[1;31m ************* Errors ***********\e[0m"
  printf -- '* %s\n' "${UPDATE_ERRORS[@]}"
fi
